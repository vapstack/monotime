# monotime 
[![GoDoc](https://godoc.org/github.com/vapstack/monotime?status.svg)](https://godoc.org/github.com/vapstack/monotime)
[![License](https://img.shields.io/badge/license-Apache2-blue.svg)](https://raw.githubusercontent.com/vapstack/monotime/master/LICENSE)

Strictly monotonic, lock-free generators for time-based identifiers.

Generators guarantee strict monotonicity even when:

- System clock is misconfigured
- Time is adjusted manually
- NTP steps the clock backward
- Process restarts with a previously stored value

This is accomplished by switching between real timestamps and logical clock
whenever the system clock falls behind.

---

## 1. Monotime

Produces raw `int64` nanosecond timestamps.
Fast and simple way to get ordered timestamps.

```go
// Initialize with the last known timestamp from your DB (or 0 for a fresh start)
mono := monotime.New(lastKnownTimestamp)

// Get the next strictly monotonic timestamp
ts1 := mono.Next() // e.g., 1731627315000000001
ts2 := mono.Next() // e.g., 1731627315000000002
```

#### Behavior

- If the system time is greater than the last emitted ID, generator uses the real timestamp.
- If the system clock ever moves backwards or stops, generator switches into logical mode,
  incrementing the internal counter until real time catches up.
- When real time becomes greater again, generator resumes using real timestamps.

## 2. MonoUUID

Produces K-sortable, time-ordered UUID v7 identifiers.\
It embeds the monotonic nanosecond timestamp directly into the UUID structure
and requires a node ID (24-bit) to ensure uniqueness across different services or cluster nodes.

This implementation also includes a custom magic prefix (0xE355) and zeroes out the `rand_a` portion,
allowing you to parse and verify that a UUID was generated by this package.

```go
// Initialize with a unique node ID and the last known UUID from your DB
// (or monotime.ZeroUUID for a fresh start)
gen, err := monotime.NewMonoUUID(nodeID, lastKnownUUID)

// Get the next strictly monotonic UUID
id1 := gen.Next() // e.g., 0124e053-3580-7000-8e35-500000100001
id2 := gen.Next() // e.g., 0124e053-3580-7000-8e35-500000100002
```

#### Behavior

UUID v7 is time-ordered by design, but it normally does not guarantee strict monotonicity.\
This implementation enforces it:

- For each generated UUID, the timestamp component is checked against the last emitted UUID.
- If the clock goes backward or stops, generator switches to logical timestamp increments.
- The nanosecond counter is incremented for each ID, ensuring uniqueness within the same millisecond.
- The generator never emits a UUID with a timestamp earlier than the previous one.

---

## Running ahead of the clock

The generators **must** produce strictly increasing IDs.\
This priority is more important than matching the system clock.

The core logic is: `next = max(now, old + 1)`

This means the generator's internal timestamp (`last`) can "run ahead" of the real system clock (`now`) 
in two specific scenarios:

1. **Clock rollback**: If the system clock moves backward (e.g., NTP update), `now` will be less than `old`.\
The generator must choose `old + 1` to maintain monotonicity.

2. **High throughput**: If `Next()` is called in a very tight loop (e.g., millions of times per second), 
`now` might be equal to `old` (or `time.Now()` hasn't ticked forward).\
The generator must choose `old + 1` to guarantee uniqueness.

In both cases, the generator starts issuing "logical" timestamps that are ahead of real time.\
This is the correct and intended behavior.

Once the system clock eventually catches up (i.e., `now` becomes greater than the generator's `last` value),
the generator will automatically switch back to using `now` as the base.

### Impact on Generators

- **Monotime**: the returned timestamp might be "in the future" compared to `time.Now().UnixNano()`.

- **MonoUUID**: the 48-bit millisecond part of the UUID will simply roll forward 
as the internal nanosecond counter increments.
For example, if the counter is at `...999_999` (last nanosecond of a millisecond) and `Next()` is called, 
the new value will be `...000_000` and the millisecond portion of the UUID will be incremented by one.
This is handled automatically by integer arithmetic and is not an error.

---

### Guarantees

- Strictly monotonic: `id_N+1 > id_N` is always true.
- No duplicates: each value is unique within a single generator instance (or `nodeID` for UUID).
- Clock-safe: resilient to system clock rollbacks, NTP adjustments, or manual time changes.
- Restart-safe: correctly resumes from the lastKnown value provided at initialization.
- Lock-free: uses CAS and never blocks.
